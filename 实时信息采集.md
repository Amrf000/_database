### 状态收集客户端脚本的设计细节  

脚本组成
distribute.py|distribute.go(两个语言版本的实现) --> 遍历部署表格(后续会在页面上传并触发),
							依次使用ssh连接到worker,  
                           上传并运行client-daemon.py,并将每个worker的部署执行结构返回-->更新表
                           以便获取过程进度和得到相关错误信息->返回操作者
                           -->另一种操作是表格(后续会在页面上传并触发),更
                           新client-daemon.ini到所有目标返回,其他要求同上
client-daemon.ini -->其中由当前指向redis的服务地址(密码)                          
client-daemon.py --> 负责根据当前redis中的版本号,维护client脚本的内容,需要能够自启和自恢复
client-[版本号].py-->内容不直接放到客户机而是放在redis中,由client-daemon.py 
                     根据redis当前版号选择,如果没有则从resis中获取
checkstate.py|checkstate.go(两个语言版本的实现) -->   schede定时检测redis中的"rdv_worker_[wk's ip]"
                      -->curenttime-updatetime>xxS的时候-->更新表
                      -->更新"rdv__device_[device's sn]"所有的isonline{n}为0
                      -->遍历rdv__device_[device's sn]统计isonline状态-->更新表
					  -->遍历rdv_worker_[wk's ip]统计内存/磁盘信息->更新表
reids 键值设计   

<table>
	<tr>
		<td>键</td>
		<td>值类型</td>
		<td>备注</td>
	</tr>
	<tr>
		<td>rdv_client_version</td>
		<td>string</td>
		<td>client.py的版本号</td>
	</tr>
	<tr>
		<td>rdv_client_run</td>
		<td>string</td>
		<td>0表示停止,1表示运行</td>
	</tr>
	<tr>
		<td>rdv_client_loop_interval</td>
		<td>string</td>
		<td>检测上报周期</td>
	</tr>
	<tr>
		<td>rdv_client_content_[版本号]</td>
		<td>string</td>
		<td>当前版本对应的client.py</br>脚本utf-8(不包含bom字节)编码正文字符串,脚本正文中也需要包含当前版本号</td>
	</tr>
	<tr>
		<td>rdv_worker_[wk's ip]"rdv_worker_[wk's ip]"</td>
		<td>array[updatetime,workerip,fullhostname,</br>memstatuspercent(0-100),diskstatuspercent(0-100)]</td>
		<td>对应一个worker的状态</td>
	</tr>
	<tr>
		<td>rdv__device_[device's sn]</td>
		<td>array[updatetime,sn,workerip,fullhostname,errorinfo,isonline0,isonline1,</br>isonline2,isonline3,isonline4]</td>
		<td>对应一个设备的状态,client.py对isonline</br>状态fifo压栈状态,第一次填充时isonline{n}默认为1</td>
	</tr>
</table>
  
 redis导出迁移   

 mysql相关键值设定( 关于数据减少的规则,如果只有时间戳不同,只更新时间戳,只关心变化)由于需要计入累计数据,关于数据删除,计算出需要的统计数据后,超过1月之外的数据删除;   
 tb_device_stamp_info   
 updatetime(timestamp) sn(varchar) workerip(varchar) workerhostname(varchar) onlinestate(tinyint) errorinfo(varchar)    
 \# 如果worker查询绑定的sn(还是所有得了,isonline堆栈去掉的话,通过updatetime间隔段得到亚健康统计,但是如果都记录的话,数据太多,关注点在5*时间间隔之内,需要设计下,不健康会有变化,似乎没问题),isonline{n}堆栈可能就不必要了   

 tb_worker_stamp_info    
 updatetime(timestamp) workerip(varchar) workerhostname(varchar) mempercent(tinyint) diskpercent(tinyint)     
 
 singleton  

  
 
 
